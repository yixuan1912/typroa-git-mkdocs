[TOC]

## 正则表达式

### 正则表达式定义（regular expression）

由一串字符和元字符构成的字符串。是包含匹配。 一般放在/  /当中。

grep  find      awk      sed      cut

----

问：用户注册时，要求用户的昵称必须为字母打头，由字母、数字、_组成的不少于8 位不多于16位的字符组成。该如何进行限制。

```shell
/[a-zA-Z]\w\{7,15\}     # \转义字符
```



----

与通配符区别 通配符：文件名的匹配，有shell解析，完全匹配

\*     任意字符

?     一个字符

[]    指[]中的任意字符

 

### 元字符

shell元字符（通配符）      rm  -rf *.txt

正则表达式元字符

| grep | ‘c*’ | /etc/passwd | 结果中含有很多不含c的行 |
| ---- | ---- | ----------- | ----------------------- |
| grep | ‘c+’ | /etc/passwd | 结果每行都含有c         |

扩展正则表达式元字符

| +    | 前一个字符匹配1次或任意多次 | ro+  |
| ---- | --------------------------- | ---- |
| ？   | 前一个字符匹配0次或1次      | ro?t |

基本元字符

.       匹配单个字符              				  r..m

\*       匹配前导符0到多次              		ro*t

.*      匹配任意字符                    			r.*t 

 

【举例】分析以下正则是否符合要求。

匹配数字： ^[0-9]+$    +表示前面的对象出现1次或多次

匹配Mail：[a-z0-9_]+@[a-z0-9]+\.[a-z]+    .表示除换行符外的任意一个 字符

匹配IP地址：[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}




分析

（1）匹配数字的正则表达式：

^[0-9]+$

（2）完整使用

```shell
[root@controller ~]#num1=123

[root@controller ~]# [[ “$num1” =~                                          ^[0-9]+$ ]] $$                                          echo “yes” || echo “no”
```

2.统计PATH环境变量中各个目录中文件的数目。 分析：

（1）明确PATH环境变量中目录；

```shell
echo  $PATH | sed  ‘s/:/  /g’
```

3．验证电子邮件是否符合username@hostname格式。注意username是由字母、数 字、点号（.）、单破折号（-）、加号（+）组成，而hostname只能由字母、数字、点号

分析：

（1）username根据规则可用的字符、符号必须出现一个才行。

([a-zA-Z0-9_\-\.]+)

（2）hostname由服务器名和域名组成，服务器名和域名都用点分隔，先指定服务器 名，紧接着指定子域名，最后是后面不带点号的顶级域名。

([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$

（3）完整写法即

^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$



4. 匹配IP

正则表达式：`[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}`

筛选出ifcfg-eno1677736中地址含有地址的行。

`egrep  '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' /etc/sysconfig/network-scripts/ifcfg-eno1677736`

将ifcfg-eno1677763中的IP地址192.168.0.1替换成192.168.0.100。 替换思路：

`:%s/192.168.0.1/192.168.0.100/`

上面这种方法我们会发现对于192.168.0.这一部分是要重复输出的，可以采用如下办法来解决重复输出的问题。

`:%s/(192.168.0.)1/\1100/`

`\1`表示第一对括号，但这种写法并不对，需要对（）进行转义。正确的

写法如下：

`:%s/\(192.168.0.\)1/\1100/`

也可以写成多括号的形式：

:%s/(192.) (168. ) (0. ) 1/\1\2\3100/                                      再加上\进行转义。

:%s/\(192.\)\ (168. \)\ (0. \) 1/\1\2\3100/

把文本中的5—10注释掉

`:5,9 s/\(.*\)/#\1/`



如果1成立，则执行2，1不成立则执行3

`[[ “$num1” =~ ^[0-9]+$ ]] && echo “number” || echo “error”`

|          1           |       2       |      3       |
| :------------------: | :-----------: | :----------: |
| $num1” =~ ^[0-9]+$ ] | echo “number” | echo “error” |

