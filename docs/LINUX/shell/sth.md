[TOC]



## 1. bash -n   shell脚本**

- 检查语法有没有错误，检测直观错误



## 2. 查看用户信息 cat /etc/passwd



## **3. password --stdin**选项

- 这个选项用于从标准输入管道读入新的密码。 

  使用 echo 方式来重置Linux 系统用户密码：

- 格式： `echo “新密码” |password --stdin 用户`



## **4. read命令**

用于从标准输入中读取输入单行，并将读取的单行根据IFS变量分裂成多个字段，并将分割后的字段分别赋值给指定的变量列表var_name。第一个字段分配给第一个变量var_name1，第二个字段分配给第二个变量var_name2，依次到结束。如果指定的变量名少于字段数量，则多出的字段数量也同样分配给最后一个var_name，如果指定的变量命令多于字段数量，则多出的变量赋值为空。

如果没有指定任何var_name，则分割后的所有字段都存储在特定变量`REPLY`中。

```选项说明：
选项说明：
-a：将分裂后的字段依次存储到指定的数组中，存储的起始位置从数组的index=0开始。
-d：指定读取行的结束符号。默认结束符号为换行符。
-n：限制读取N个字符就自动结束读取，如果没有读满N个字符就按下回车或遇到换行符，则也会结束读取。
-N：严格要求读满N个字符才自动结束读取，即使中途按下了回车或遇到了换行符也不结束。其中换行符或回车算一个字符。
-p：给出提示符。默认不支持"\n"换行，要换行需要特殊处理，见下文示例。例如，"-p 请输入密码："
-r：禁止反斜线的转义功能。这意味着"\"会变成文本的一部分。
-s：静默模式。输入的内容不会回显在屏幕上。
-t：给出超时时间，在达到超时时间时，read退出并返回错误。也就是说不会读取任何内容，即使已经输入了一部分。
-u：从给定文件描述符(fd=N)中读取数据。
```



## **5. &>/dev/null表示的意思**

在Linux/Unix中，一般在屏幕上面看到的信息是从**stdout (standard output)** 或者 **stderr (standard error output)** 来的。许多人会问，output 就是 output，送到屏幕上不就得了，为什麼还要分成stdout 和 stderr 呢？那是因为通常在 server 的工作环境下，几乎所有的程序都是 run 在 background 的，所以呢，为了方便 debug，一般在设计程序时，就把**stdout 送到/存到一个档案，把错误的信息 stderr 存到不同的档案。**

哪些是正常的output呢，例如程序开始运行的时间，现在正在上线人数等等。

哪些是错误的output呢，例如无法找到使用者想要去的URL，或者信用卡认证失败等等。

---

`/dev/null` 是 Unix/Linux 里的【**无底洞**】

任何的 output 送去了【无底洞】就再也没了。相信我，真的没了！

那麼有人问，在什麼情况下要把 output 送去这无底洞呢？这里没有标准答案，不过一般呢，要是你不想看到 output 或者output 太多太大了，有可能把硬碟给挤爆了的时候，程序的设计就会考虑把 output 送到 /dev/null 了。

---

用 /dev/null 2>&1 这样的写法.这条命令的意思是将标准输出和错误输出全部重定向到/dev/null中,也就是将产生的所有信息丢弃.

   下面就为大家来说一下, **command > file 2>file**  与**command > file 2>&1** 有什么不同的地方.

​      首先 **command > file 2>file** 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file中 **command  > file 2>file** 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道.

​      而**command >file 2>&1** 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容.

​      从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会用**command > file 2>&1** 这样的写法.

关于shell中：>/dev/null 2>&1 详解

shell中可能经常能看到：>/dev/null 2>&1

命令的结果可以通过%>的形式来定义输出

分解这个组合：“>/dev/null 2>&1” 为五部分。

1：> 代表重定向到哪里，例如：echo "123" > /home/123.txt
2：/dev/null 代表空设备文件
3：2> 表示stderr标准错误
4：& 表示等同于的意思，2>&1，表示2的输出重定向等同于1
5：1 表示stdout标准输出，系统默认值是1，**所以">/dev/null"等同于 "1>/dev/null"**

因此，**>/dev/null 2>&1也可以写成“1> /dev/null 2> &1”**

那么本文标题的语句执行过程为：
1>/dev/null ：首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。
2>&1 ：接着，标准错误输出重定向 到标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。



## 6.userdel 删除用户

`userdel -r`   删除用户及其主目录



## 7. mkdir

```shell
-m=mode    为目录指定访问权限，与chmod类似。

-p　　如果目录已经存在，则不会有错误提示。若父目录不存在，将会创建父目录。该选项常用于创建级联目录。

-v　　为每个目录显示提示信息。
```



## 8. 控制返回值

```shell
exit number
number就是设置的返回值
```



## 9. 获取字符串长度

```shell
方法1: 使用wc -L命令
wc -L可以获取到当前行的长度，因此对于单独行的字符串可以用这个简单的方法获取，另外wc -l则是获取当前字符串内容的行数。
代码如下:
echo "abc" |wc -L

方法2: expr length string
使用expr length可以获取string的长度

方法3: awk获取域的个数，但是如果大于10个字符的长度时是否存在问题需要后面确认
代码如下:
echo "abc" |awk -F "" '{print NF}'

方法4: 通过awk+length的方式获取字符串长度
代码如下:
echo “Alex”|awk '{print length($0)}'

方法5: 通过echo ${#string}的方式（注意：这里的string是该字符串的变量名）
代码如下:
name=Alex
echo ${#name}
```



## 10.`tee`把输出追加到文件

> Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。
>
> tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。

### 语法

```shell
tee [-ai][--help][--version][文件...]
```

**参数**：

- -a或--append 　追加，而非覆盖它．
- -i或--ignore-interrupts 　忽略中断信号。
- --help 　在线帮助。
- --version 　显示版本信息。

```shell
#!同时保存到文件"file1"和"file2"中
$ tee file1 file2          
```



## 11.time命令计算耗时

任何命令、脚本前都可以加`time`命令,来查看耗时

```shell
[root@Xuan shell-works]$ time ls
add_table_cbp.sh  disk_cbp.sh  test.sh  user.sh  yum_config.sh

real	0m0.002s
user	0m0.000s
sys	0m0.002s
```



## 12.seq输出数字序列

**参数**

- -s   指定分隔符，默认分隔符是\n
- -w   使用0填充左边达到所有的数字长度一样

```shell
seq 5
1
2
3
4
5
```



## 13. 命令：let计算工具

let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。

**语法格式**

```
let arg [arg ...]
```

**参数说明：**

arg：要执行的表达式

**实例：**

自加操作：**let no++**

自减操作：**let no--**

简写形式 **let no+=10，let no-=20**，分别等同于 **let no=no+10，let no=no-20**。



## linux top命令

**VIRT：virtual memory usage 虚拟内存**1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等
2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量

**RES：resident memory usage 常驻内存**
1、进程当前使用的内存大小，但不包括swap out
2、包含其他进程的共享
3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反
4、关于库占用内存的情况，它只统计加载的库文件所占内存大小

**SHR：shared memory 共享内存**
1、除了自身进程的共享内存，也包括其他进程的共享内存
2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小
3、计算某个进程所占的物理内存大小公式：RES – SHR
4、swap out后，它将会降下来

**DATA**
1、数据占用的内存。如果top没有显示，按f键可以显示出来。
2、真正的该程序要求的数据空间，是真正在运行中要使用的。

**top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下：**

```SHE
s – 改变画面更新频率
l – 关闭或开启第一部分第一行 top 信息的表示
t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示
m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示
N – 以 PID 的大小的顺序排列表示进程列表
P – 以 CPU 占用率大小的顺序排列进程列表
M – 以内存占用率大小的顺序排列进程列表
h – 显示帮助
n – 设置在进程列表所显示进程的数量
q – 退出 top
s – 改变画面更新周期
```

```SHE


序号 列名 含义
a PID 进程id
b PPID 父进程id
c RUSER Real user name
d UID 进程所有者的用户id
e USER 进程所有者的用户名
f GROUP 进程所有者的组名
g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?
h PR 优先级
i NI nice值。负值表示高优先级，正值表示低优先级
j P 最后使用的CPU，仅在多CPU环境下有意义
k %CPU 上次更新到现在的CPU时间占用百分比
l TIME 进程使用的CPU时间总计，单位秒
m TIME+ 进程使用的CPU时间总计，单位1/100秒
n %MEM 进程使用的物理内存百分比
o VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
p SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。
q RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
r CODE 可执行代码占用的物理内存大小，单位kb
s DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb
t SHR 共享内存大小，单位kb
u nFLT 页面错误次数
v nDRT 最后一次写入到现在，被修改过的页面数。
w S 进程状态。（D=不可中断的睡眠状态，R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）
x COMMAND 命令名/命令行
y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名
z Flags 任务标志，参考 sched.h

默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。

通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。
按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。
按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。
```



## 14 文件磁盘操作

### **5.8日 更改文件权限,文 件预设权限**

- **alias**指定**终端**的快捷键(**只有当前窗口有用**)

  **`alias 快捷键="命令"`**

- 文件权限rwx 对应421

  | 原始权限  |    转换为数字     | 数字表示法 |
  | :-------: | :---------------: | :--------: |
  | rwxrwxr-x | (421) (421) (401) |    775     |
  | rwxr-xr-x | (421) (401) (401) |    755     |
  | rw-rw-r-- | (420) (420) (400) |    664     |
  | rw-r-r--  | (420) (400) (400) |    644     |

- **1.更改文件权限**

  - **方法1:** **`chmod 数字表示法 文件`**
  - **方法2:`chmod u=rw,g=rw,o=r 文件名`**
  - **`chmod a=rw 文件名`**可以将所有人都设置为rw权限

- **2.文件的特殊权限(SUID权限 )**

  - 特殊权限**`chmod u+s 文件名`**
  - **`chmod 6664 文件名`**权限显示为:**-rwSrwSr--** 

- **3.文件预设权限: umask**

  - `umask` 默认是去掉权限
  - `umask 022`表示为: 去掉**`w`**权限
  - **注意: **用文件默认属性**666** 与目录默认属性**777**来与**umask**相加减是不对的.  比如: **666-003=663**即**-rw-rw--wx** 原本的文件是没有默认权限**`x`**的, 但是这里就多了`x`权限

### ** 文件隐藏属性,特殊权限**

- **文件隐藏属性(p82) :**

  1.**chattr**: 改变文件属性

  - **语法: `chattr [-RV][-v<版本号>][+/-/+<属性][文件目录]`**
  - **常用命令**`chattr +a 文件名`: 只允许在这个文件后追加数据,不允许任何进程覆盖或截断这个文件. 如果目录具有这个属性, 系统只允许在这个目录下建立和修改文件, 而不允许删除任何文件
  - `chattr +i 文件名` : 不得任意改动文件和目录

- **chattr参数: **

  - `-R`: 递归处理,将目录下的所有的子文件一并处理
  - `-v<版本号>`: 设置文件或目录版本
  - `+<属性>`: 开启文件或目录的该项属性
  - `-<属性>`: 关闭文件或目录的该项属性
  - `=<属性>`: 指定文件或目录的该项属性 

- 2.**lsattr**: 显示文件隐藏属性

  - **语法**: `lsattr [-adR] 文件或目录`

  - **参数**:  `-a`: 将隐藏的文件的属性也显示出来

    `-d`: 如果连接的是目录, 仅列出目录本身的属性,而非目录内的文件名

    `-R`: 连子目录的数据也一并列出来

- **文件的特殊权限:(SUID  SGID  SBIT)** 三个分别对应`4 2 1`  设为`0`就是无

  **`SUID`**的限制与功能:

  - 一般显示为`s 或 S`
  - SUID 权限仅对**二进制程序**(**命令端**)有效
  - 执行者于该程序需要有`x`的可执行权限
  - 本权限仅在执行该程序过程中有效
  - 执行者将具有该程序拥有者(**root**)的权限

  **`SGID`** :设置在文件上面,效果与SUID相同,只不过将文件所有者换成用户组

  **`SBID`**: 只对目录有效

  - 就是自己在该目录下创建的文件,只有自己能移动, 删除, 更名. 别人无法删除, 也无法删除别人的文件 

  

## **15 配置与管理磁盘**

> ###### 以下仅以新增一块SCSI硬盘位前提, 新增的硬盘位 /dev/sdb

- **1.fdisk:**

  **命令:**

  `fdisk /dev/sdb`: 打开`fdisk`命令操作界面

  | 命令 |          功能          | 命令 |           功能           |
  | :--: | :--------------------: | :--: | :----------------------: |
  |  a   |    调整硬盘启动分区    |  q   |        不保存退出        |
  |  d   |      删除硬盘分区      |  t   |       更改分区类型       |
  |  l   | 列出所有支持的分区类型 |  u   | 切换所显示的分区大小单位 |
  |  m   |      列出所有命令      |  w   |    把修改写入然后退出    |
  |  n   |       创建新分区       |  x   |       列出高级选项       |
  |  p   |      列出硬盘列表      |      |                          |

- 2.**mkfs: 格式化硬盘**

  命令格式: `mkfs [参数] 文件新系统`

  常用命令: `-t`:指定要创建的文件系统类型

  ​                  `-c`: 建立文件系统前首先检查坏块

  ​                  `-l`: 从文件file 中读取磁盘坏块列表, file文件一般是由吸盘坏块检查程序产生的

  ​                   `-V`: 输出建立文件系统详细信息

  ##### 格式化代码演示:

  ###### 2.1 对软盘格式化: `mkfs -t ext3 -V -c /dev/sdb1`

  ###### 2.2 用`badblock`命令检查坏块, 把信息存储到`badblock-fd0`中: `badblock /dev/fd0  1440>badblock-fd0`

  ###### 2.3 用`mkfs`命令建立文件系统: `mkfs -t ext3 -l badblock-fd0 /dev/fd0`

- 3.**`mount 选项 设备 挂载点` : 挂载文件系统**

  参数: `-t`: 指定要挂载的文件系统的类型

  ​                   `-r`: 如果不想修改要挂载的文件系统, 可以以只读的方式挂载

  ​                   `-w`: 以可写的方式挂载文件系统

  ​                   `-a`: 挂载`/etc//fstab` 文件中记录的设备

  挂载，指向不一样

  *注意: 书上的设备写的是 `/dev/cdrom`*

  3.1 **卸载**

  格式:  `umount 设备 挂载点`

  命令: 1.`umount /dev/cdrom /挂载点`

  ​          2.`umount 设备`

  ​	  	3.`umount 挂载点`



```she
扩展逻辑卷的大小    （ LVextend   -L   +2G   /dev/VolGroup00/LogVol00）

使用resizefs2命令重新加载逻辑卷的大小才能生效。 
（ resize2fs   /dev/VolGroup00/LogVol00）
如果不用这个的话，df -h 看不到
```



## **16 Linux暂停和恢复进程**

kill -STOP 1234 将该进程暂停。 
如果要让它恢复到后台，用kill -CONT 1234 （很多在前台运行的程序这样是不行的） 
如果要恢复到前台，请在当时运行该进程的那个终端用jobs命令查询暂停的进程。 
然后用 fg 〔job号〕把进程恢复到前台。  

如果jobs只查询到一个进程，只用 fg 即可。 

```she
例：root@dWorks:~# bc -q
[1]+  Stopped                 bc -q 
root@dWorks:~# bc -q  
[2]+  Stopped                 bc -q 
root@dWorks:~# jobs 
[1]-  Stopped                 bc -q 
[2]+  Stopped                 bc -q 
root@dWorks:~# fg 2
bc -q
1+1
2
A,Shell支持作用控制，有以下命令：

1. command& 让进程在后台运行
2. jobs 查看后台运行的进程
3. fg %n 让后台运行的进程n到前台来
4. bg %n 让进程n到后台去；
5. PS:"n"为jobs查看到的进程编号.


察看jobs
使用jobs或ps命令可以察看正在执行的jobs。
jobs 命令执行的结果，＋表示是一个当前的作业，减号表是是一个当前作业之后的一个作业，jobs -l选项可显示所有任务的PID,jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令 显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息；
进程的挂起
后台进程的挂起：
在solaris中通过stop命令执行，通过jobs命令查看job号(假设为num)，然后执行stop %num； 　　 
在redhat中，不存在stop命令，可通过执行命令kill -stop PID，将进程挂起； 　　 
当要重新执行当前被挂起的任务时，通过bg %num 即可将挂起的job的状态由stopped改为running，仍在后台执行；
当需要改为在前台执行时，执行命令fg %num即可； 　　 
前台进程的挂起：
ctrl+Z;
进程的终止
后台进程的终止：
方法一：　　通过jobs命令查看job号（假设为num），然后执行kill %num 　　 
方法二：　　通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid 　　 
前台进程的终止：
ctrl+c
kill的其他作用
kill除了可以终止进程，还能给进程发送其它信号，使用kill -l 可以察看kill支持的信号。
SIGTERM是不带参数时kill发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。如果进程还没有终止，可以使用kill -SIGKILL pid，这是由内核来终止进程，进程不能监听这个信号。
```







## END